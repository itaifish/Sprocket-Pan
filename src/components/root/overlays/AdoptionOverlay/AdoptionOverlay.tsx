import { OrphanData } from '@/managers/data/WorkspaceDataManager';
import { selectEndpoints, selectServices } from '@/state/active/selectors';
import { Button, Sheet, Stack, Typography } from '@mui/joy';
import { useSelector } from 'react-redux';
import { OrphanResolution, OrphanResolutionDropdown } from './OrphanResolutionDropdown';
import { useMemo, useState } from 'react';
import { Check, Timer } from '@mui/icons-material';
import { OrphanResolutionSummary } from './OrphanResolutionSummary';
import { SprocketTooltip } from '@/components/shared/SprocketTooltip';
import { useAppDispatch } from '@/state/store';
import { activeActions } from '@/state/active/slice';
import { addNewService } from '@/state/active/thunks/services';
import { tabsActions } from '@/state/tabs/slice';
import { addNewEndpoint, deleteEndpoint } from '@/state/active/thunks/endpoints';
import { groupBy } from '@/utils/variables';
import { deleteRequest } from '@/state/active/thunks/requests';

interface AdoptionOverlayProps {
	orphans: OrphanData | null;
	onClose: () => void;
}

type OrphanStrategy = Record<string, string | OrphanResolution>;

const resVals: string[] = Object.values(OrphanResolution);

function getGroup(strat?: string) {
	if (strat == null) return OrphanResolution.none;
	if (resVals.includes(strat)) return strat;
	return OrphanResolution.assign;
}

const autogenService = {
	description: 'Autogenerated Service',
	baseUrl: 'unknown',
	name: 'Autogenerated Service',
};

const autogenEndpoint = { name: 'Autogenerated Endpoint' };

export function AdoptionOverlay({ orphans, onClose }: AdoptionOverlayProps) {
	const [strategy, setStrategy] = useState<OrphanStrategy>({});
	const services = useSelector(selectServices);
	const endpoints = useSelector(selectEndpoints);
	const serviceList = useMemo(() => Object.values(services), [services]);
	const endpointList = useMemo(() => Object.values(endpoints), [endpoints]);
	const dispatch = useAppDispatch();

	if (orphans == null) return null;

	const onApply = async () => {
		const {
			[OrphanResolution.delete]: deleteEndpoints,
			[OrphanResolution.create]: createEndpoints,
			[OrphanResolution.revive]: reviveEndpoints,
			[OrphanResolution.assign]: assignEndpoints,
		} = groupBy(orphans.endpoints, (item) => getGroup(strategy[item.orphan.id]));
		const {
			[OrphanResolution.delete]: deleteRequests,
			[OrphanResolution.create]: createRequests,
			[OrphanResolution.revive]: reviveRequests,
			[OrphanResolution.assign]: assignRequests,
		} = groupBy(orphans.requests, (item) => getGroup(strategy[item.orphan.id]));

		const revivedIds = new Set<string>();

		reviveEndpoints.forEach(({ parent }) => {
			if (parent == null) throw new Error('trying to revive a non-existent parent');
			if (!revivedIds.has(parent.id)) {
				dispatch(activeActions.insertService(parent));
				revivedIds.add(parent.id);
			}
		});
		reviveRequests.forEach(({ parent, grandparent }) => {
			if (parent == null || grandparent == null)
				throw new Error('trying to revive a non-existent parent or grandparent');
			if (!revivedIds.has(grandparent.id) && services[grandparent.id] == null) {
				dispatch(activeActions.insertService(grandparent));
				revivedIds.add(grandparent.id);
			}
			if (!revivedIds.has(parent.id)) {
				dispatch(activeActions.insertEndpoint(parent));
				revivedIds.add(parent.id);
			}
		});

		deleteRequests?.forEach(({ orphan }) => dispatch(deleteRequest(orphan.id)));
		deleteEndpoints?.forEach(({ orphan }) => dispatch(deleteEndpoint(orphan.id)));

		assignEndpoints?.forEach(({ orphan }) =>
			activeActions.addEndpointToService({ endpointId: orphan.id, serviceId: strategy[orphan.id] }),
		);
		assignRequests?.forEach(({ orphan }) =>
			activeActions.addRequestToEndpoint({ requestId: orphan.id, endpointId: strategy[orphan.id] }),
		);

		if (createEndpoints?.length || createRequests?.length) {
			const serviceId = await dispatch(addNewService(autogenService)).unwrap();
			createEndpoints?.forEach(({ orphan }) =>
				dispatch(activeActions.addEndpointToService({ endpointId: orphan.id, serviceId })),
			);
			if (createRequests?.length) {
				const endpointId = await dispatch(
					addNewEndpoint({
						serviceId,
						data: autogenEndpoint,
					}),
				).unwrap();
				createRequests?.forEach(({ orphan }) =>
					dispatch(activeActions.addRequestToEndpoint({ requestId: orphan.id, endpointId })),
				);
			}
		}

		dispatch(tabsActions.setOrphans(null));
	};
	return (
		<Sheet sx={{ overflowY: 'auto', px: '20px', height: '85vh', width: '600px', maxWidth: '100%' }}>
			<Stack gap={2} height="100%">
				<Typography level="body-md">
					Endpoints without parent Services and/or Requests without parent Endpoints have been detected. You can decide
					what to do with each of them using the dropdowns below.
				</Typography>
				{orphans.endpoints.length > 0 && <Typography level="title-md">Endpoints</Typography>}
				{orphans.endpoints.map(({ orphan, parent }) => {
					return (
						<OrphanResolutionDropdown
							value={strategy[orphan.id]}
							parentType="Service"
							key={orphan.id}
							name={orphan.name}
							parent={parent}
							adoptors={serviceList}
							onChange={(id) => setStrategy({ ...strategy, [orphan.id]: id })}
						/>
					);
				})}
				{orphans.requests.length > 0 && <Typography level="title-md">Requests</Typography>}
				{orphans.requests.map(({ orphan, parent }) => {
					return (
						<OrphanResolutionDropdown
							value={strategy[orphan.id]}
							parentType="Endpoint and Service"
							key={orphan.id}
							name={orphan.name}
							parent={parent}
							adoptors={endpointList}
							onChange={(id) => setStrategy({ ...strategy, [orphan.id]: id })}
						/>
					);
				})}
				<Typography level="title-md">Summary</Typography>
				<OrphanResolutionSummary strategy={strategy} />
				<Stack direction="row" gap={1} justifyContent="end">
					<SprocketTooltip text="Orphaned items will remain inaccessible until next workspace load.">
						<Button color="warning" startDecorator={<Timer />} onClick={onClose}>
							Decide Later
						</Button>
					</SprocketTooltip>
					<Button color="success" sx={{ width: '200px' }} startDecorator={<Check />} onClick={onApply}>
						Apply
					</Button>
				</Stack>
			</Stack>
		</Sheet>
	);
}
